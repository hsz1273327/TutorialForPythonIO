# RPC接口服务

RPC(Remote Procedure Call)--远程过程调用,是一种通过网络从远程计算机程序上请求服务.它会封装底层网络技术,调用者只需要像调用一般函数一样调用RPC而不需要了解底层网络技术的协议.RPC协议假定某些传输协议的存在,如TCP或UDP,为通信程序之间携带信息数据.在OSI网络通信模型中,RPC跨越了传输层和应用层.


RPC采用请求/应答模式,请求程序就是一个客户端,而应答方就是一个服务器.在使用上与一般的函数调用很相似,首先请求端调用进程发送一个有进程参数的调用信息到服务进程,然后等待应答信息;在应答端.进程保持睡眠状态直到调用信息到达为止.当一个调用信息到达,服务器获得进程参数并计算结果,发送答复信息,然后等待下一个调用信息;最后,客户端调用进程接收答复信息,获得进程结果,然后调用执行继续进行.

RPC一般用于封装无状态服务,通常是类似函数的计算过程.因此RPC的接口也和函数签名类似.

解构RPC的实现,无外乎2个元素:

+ 传输协议,常见的有`http 1.1`,`http 2.0`,`tcp`.
    `http`协议由于自带一个很大的header,而且表示层使用字符串而非字节流,所以通常来讲性能不高,但可读性好便于debug,而且主流的反向代理工具对http协议的支持是最好的,因此可以比较方便的构建集群.
    
    `http 1.1`由于只支持短连接,也就是说每次请求都必须建立连接,消耗的资源会比较多,因此基于`http 1.1`的RPC协议通常性能都不太行.因为不支持流,所以表现力受限.
    `http 2.0`由于支持长连接(管道技术),同时支持流,所以基于它的RPC协议通常表现力更丰富,资源消耗也会降低,性能会好上很多.
    
    `TCP`是第4层协议,也就是说并没有规定会话和表现层协议,因此会更加灵活,基于它的RPC协议通常更加灵活高效,但开发维护会更加麻烦也更加不好调试.也有使用`ZEROMQ`作为传输协议的,这样既解决了会话层协议,也为请求提供了一个缓存.
    
+ [序列化协议](http://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E8%8A%82%E5%BA%8F/%E5%BA%8F%E5%88%97%E5%8C%96.html),常见的有`xml`,`json`,`protobuf`,`msgpack`


本部分将会介绍几种常见的RPC框架

+ `XMLRPC`标准库自带的RPC框架,基于`http 1.1`和`xml`,古老的技术,可以用于快速实现,但并不适合高负载下使用

+ `JSONRPC`,`XMLRPC`的改进版,基于`http 1.1`和`JSON`,使用相对轻量级的JSON作为序列化协议,性能比`XMLRPC`好点有限,同样可以用于快速实现,但并不适合高负载下使用

+ `ZERORPC`,使用ZEROMQ做消息传输,用`msgpack`做序列化协议,性能较好,也可以抗一定的并发,但目前支持的语言有限,官方只支持python和js,有第三方提供了golang和php的支持
+ `GRpc`,谷歌开源的RPC框架,使用`http 2.0`作为传输协议,用`protobuf`作为序列化协议,性能优异,表现力也好,支持传输流


